<?php

/**
 * Generated by ZF2ModuleCreator
 */

namespace ZF3Belcebur\DoctrineORMFastApi;

use Exception;
use Zend\EventManager\EventInterface;
use Zend\Http\PhpEnvironment\Request;
use Zend\Http\PhpEnvironment\Response;
use Zend\ModuleManager\Feature\BootstrapListenerInterface;
use Zend\ModuleManager\Feature\ConfigProviderInterface;
use Zend\ModuleManager\Feature\DependencyIndicatorInterface;
use Zend\ModuleManager\Feature\ServiceProviderInterface;
use Zend\ModuleManager\Listener\ConfigListener;
use Zend\ModuleManager\ModuleEvent;
use Zend\ModuleManager\ModuleManager;
use Zend\Mvc\MvcEvent;
use Zend\ServiceManager\Config;
use Zend\View\Model\JsonModel;
use ZF3Belcebur\DoctrineORMFastApi\Factory\HydratorWithStrategiesFactory;
use ZF3Belcebur\DoctrineORMFastApi\Factory\ConfigReflectionFactory;
use ZF3Belcebur\DoctrineORMFastApi\Factory\Strategy\CollectionStrategyFactory;
use ZF3Belcebur\DoctrineORMFastApi\Factory\Strategy\EntityStrategyFactory;
use ZF3Belcebur\DoctrineORMFastApi\Resource\ConfigReflection;
use ZF3Belcebur\DoctrineORMFastApi\Resource\HydratorWithStrategies;
use ZF3Belcebur\DoctrineORMFastApi\Strategy\CollectionStrategy;
use ZF3Belcebur\DoctrineORMFastApi\Strategy\EntityStrategy;
use function get_class;
use function key;
use function preg_match;

class Module implements ConfigProviderInterface, ServiceProviderInterface, DependencyIndicatorInterface, BootstrapListenerInterface
{

    public const CONFIG_KEY = __NAMESPACE__;

    /**
     * Returns configuration to merge with application configuration
     *
     * @return array
     */
    public function getConfig(): array
    {
        return include __DIR__ . '/../config/module.config.php';
    }

    /**
     * Expected to return \Zend\ServiceManager\Config object or array to
     * seed such an object.
     *
     * @return array|Config
     */
    public function getServiceConfig(): array
    {

        return [
            'factories' => [
                HydratorWithStrategies::class => HydratorWithStrategiesFactory::class,
                EntityStrategy::class => EntityStrategyFactory::class,
                CollectionStrategy::class => CollectionStrategyFactory::class,
                ConfigReflection::class => ConfigReflectionFactory::class,
            ],
        ];
    }

    public function onError(MvcEvent $event)
    {
        $targetClass = get_class($event->getTarget());
        if (preg_match('#^' . __NAMESPACE__ . '(\\\\)?#', $targetClass)) {
            if (!$event->isError()) {
                return $event;
            }
            /** @var Response $response */
            /** @var Exception $exception */
            $response = $event->getResponse();
            $exception = $event->getParam('exception');
            $exceptionJson = [];
            if ($exception) {
                $exceptionJson = [
                    'class' => get_class($exception),
                    'file' => $targetClass,
                    'line' => $exception->getLine(),
                    'trace' => $exception->getTrace(),
                ];
            }
            $errorJson = [
                'message' => $exception ? $exception->getMessage() : $response->getReasonPhrase(),
                'error' => $event->getError(),
                'exception' => $exceptionJson,
            ];

            $model = new JsonModel($errorJson);
            $event->setResult($model);
            return $model;
        }
        return $event;
    }

    public function onFinish(MvcEvent $event)
    {
        $targetClass = get_class($event->getTarget());
        if (preg_match('#^' . __NAMESPACE__ . '(\\\\)?#', $targetClass)) {
            /** @var Request $request */
            /** @var Response $response */
            /** @var Exception $exception */
            $response = $event->getResponse();
            $request = $event->getRequest();
            $viewModel = $event->getViewModel();
            $params = [
                'GET' => $request->getQuery(),
                'POST' => $request->getPost(),
                'PUT' => $response->getHeaders(),
                'DELETE' => $response->getHeaders(),
            ];
            $viewModel->setVariables([
                'status-message' => $response->getReasonPhrase(),
                'status-code' => $response->getStatusCode(),
                'url' => $request->getUriString(),
                'method' => $request->getMethod(),
                'params' => $params[$request->getMethod()] ?? [],
                'error' => $response->getStatusCode() !== 200,
            ]);

            $event->setViewModel($viewModel);
        }
    }

    /**
     * Expected to return an array of modules on which the current one depends on
     *
     * @return array
     */
    public function getModuleDependencies(): array
    {
        return ['DoctrineModule', 'DoctrineORMModule'];
    }


    /**
     * Listen to the bootstrap event
     *
     * @param MvcEvent|EventInterface $event
     *
     * @return void
     */
    public function onBootstrap(EventInterface $event): void
    {
        $app = $event->getApplication();
        $eventManager = $app->getEventManager();
        //handle the dispatch error (exception)
        $eventManager->attach(MvcEvent::EVENT_DISPATCH_ERROR, [$this, 'onError']);
        //handle the view render error (exception)
        $eventManager->attach(MvcEvent::EVENT_RENDER_ERROR, [$this, 'onError']);
        $eventManager->attach(MvcEvent::EVENT_RENDER, [$this, 'onFinish'], -100);
    }


    public function init(ModuleManager $moduleManager)
    {
        $events = $moduleManager->getEventManager();

        // Registering a listener at default priority, 1, which will trigger
        // after the ConfigListener merges config.
        $events->attach(ModuleEvent::EVENT_MERGE_CONFIG, [$this, 'onMergeConfig']);
    }

    public function onMergeConfig(ModuleEvent $e)
    {
        /** @var ConfigListener $configListener */
        $configListener = $e->getConfigListener();
        $config = $configListener->getMergedConfig(false);

        $apiRoute = $config[__NAMESPACE__]['route'];
        $apiRouteName = key($apiRoute);

        $config['router']['routes'][$apiRouteName] = $apiRoute[$apiRouteName];
        // Pass the changed configuration back to the listener:
        $configListener->setMergedConfig($config);
    }
}
